1、右值引用解决的问题？
 （1）：临时对象非必要的昂贵拷贝操作；（2）：模板函数中如何按照参数的实际类型进行转发。
2、区分左值 和右值：看能不能对表达式取地址

3、纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值
     将亡值：将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值

4、右值引用的特点？
   （1）：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。
   （2）：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
   （3）：T&& t在发生自动类型推断的时候，它是未定的引用类型（universal references），如果被一个左值初始化，它就是一个左值；
                如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。
   （4）：

5、std：：move：std::move方法来将左值转换为右值，从而方便应用移动语义。move是将对象资源的所有权从一个对象转移到另一个对象，只是转移，没有内存的拷贝，这就是所谓的move语义。
                            这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。
                            如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。

6、std：：forwarf：完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。

7、std::move()和std::forward()对比
std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。
std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。
std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。

https://www.cnblogs.com/likaiming/p/9029908.html

https://www.jianshu.com/p/b90d1091a4ff