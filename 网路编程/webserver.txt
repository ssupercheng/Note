1、为什么使用ET模式？
LT和ET的区别：
LT对于存在未读完的数据，下一次调用epoll_wait还会触发，
ET无论是否读完，只触发一次，直到下一次EPOLLIN事件到来

LT的优点：易于编码，未读完的数据下次还能继续读，不易遗漏
ET的缺点：难以编码，需要一次读完，有时会遗漏

LT的缺点：在并发量高的时候，epoll_wait返回的就绪队列比较大，遍历比较耗时。因此LT适用于并发量小的情况（每次返回的就绪队列中都有此socket），如果此模式下也是循环读取，那么下次也会触发？？
ET的优点：并发量大的时候，就绪队列要比LT小得多，效率更高（需要一次读完，那么下次epoll返回的就绪队列中就没有此socket，那么轮询的此时就会变少）

对于accept（）：多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。
                解决办法是用while循环抱住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。
				
				

2、套接字的阻塞和非阻塞？
（1） 对于IO套接字，无论是ET还是LT，若为阻塞模式，那么在while(recv())这里，读完数据之后，如果没有数据来的话，就会阻塞在这里，那么就不会继续返回到外面的while（1）的大循环中了。
      也就不会再epollwait函数那里阻塞了（也就是没有办法委托再去内核检测了），这就完全把整个程序的功能弄错了。
（2）阻塞模式下accept（）：：TCP连接被客户端夭折，即在服务器调用accept之前，客户端主动发送RST终止连接，导致刚刚建立的连接从就绪队列中移出，
      如果套接口被设置成阻塞模式，服务器就会一直阻塞在accept调用上，直到其他某个客户建立一个新的连接为止。
	  但是在此期间，服务器单纯地阻塞在accept调用上，就绪队列中的其他描述符都得不到处理。 
	  解决办法是把监听套接口设置为非阻塞，当客户在服务器调用accept之前中止某个连接时，accept调用可以立即返回-1
 
 
 
 
 
 
 
 3、四种组合:
 (1)LT+阻塞：此模式下不能用while(recv())，因为会阻塞在最后一次调用，所以只能每次读写一次，这样就造成了每次该套接字都会在epoo的readyList，造成开销较大。
 (2)LT+非阻塞：
 (3)ET+阻塞：此模式下不能用while(recv())，因为会阻塞在最后一次调用，所以只能每次读写一次，这样就会造成数据无法全部读完，所以只能用非阻塞形式。
 (4)ET+非阻塞：
 
 4、epoll_wait函数的阻塞与在其队列中socket是否阻塞没有关系，即添加在epoll中的socket全为阻塞，epoll_wait也不会阻塞，除非有事件触发或timeout。
 
 5、epoll的ET模式下怎么处理旧数据（丢弃）
 
 6、epolloneshot：epoll上注册这个事件，注册这个事件后，如果在处理写成当前的SOCKET后不再重新注册相关事件，那么这个事件就不再响应了或者说触发了。这样就可以通过手动的方式来保证同一SOCKET只能被一个线程处理，不会跨越多个线程
 
 
 
